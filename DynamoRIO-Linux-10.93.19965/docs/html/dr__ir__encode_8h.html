<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>DynamoRIO: /home/runner/work/dynamorio/dynamorio/build_release-32/include/dr_ir_encode.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dr__ir__encode_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dr_ir_encode.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encoding routines.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1ab4eb589819195ae2674b22546e3b4a"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074a">_dr_isa_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a></td></tr>
<tr class="separator:a1ab4eb589819195ae2674b22546e3b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a00e03b2e5e75a83eacf9a0ee1674074a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074a">_dr_isa_mode_t</a> { <br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa4216aed26374dfaaf5b8e64c8bfc9c6c">DR_ISA_IA32</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa6bec3bf2d3d264dfa7dbf67d18b47c41">DR_ISA_X86</a> = DR_ISA_IA32, 
<br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aabd60fe0abfbb90ba431205b7e5345ac0">DR_ISA_AMD64</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa28dc5f6ff81766706362bfb7494a0494">DR_ISA_ARM_A32</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa3f721209faa0616ff181a7bf207a59cc">DR_ISA_ARM_THUMB</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aaefbc35f57a99a1464fda9d6d75dd8445">DR_ISA_ARM_A64</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa9afde26779516aec4b89b27bb67e5b18">DR_ISA_RV64</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a>
<br />
 }</td></tr>
<tr class="separator:a00e03b2e5e75a83eacf9a0ee1674074a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a988d4acb4851873453253a91d9521bce"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#a988d4acb4851873453253a91d9521bce">dr_set_isa_mode</a> (void *drcontext, <a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a> new_mode, <a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a> *old_mode DR_PARAM_OUT)</td></tr>
<tr class="separator:a988d4acb4851873453253a91d9521bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f9b08f90490fbeae26d12a461af084"><td class="memItemLeft" align="right" valign="top">DR_API <a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#ae8f9b08f90490fbeae26d12a461af084">dr_get_isa_mode</a> (void *drcontext)</td></tr>
<tr class="separator:ae8f9b08f90490fbeae26d12a461af084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3e82d2bfed58e3bfc89c0b98f2a5da"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#afd3e82d2bfed58e3bfc89c0b98f2a5da">dr_set_vector_length</a> (int vl)</td></tr>
<tr class="separator:afd3e82d2bfed58e3bfc89c0b98f2a5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f30c1c72bf9891979a428ddf7a03c0"><td class="memItemLeft" align="right" valign="top">DR_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#aa7f30c1c72bf9891979a428ddf7a03c0">dr_get_vector_length</a> (void)</td></tr>
<tr class="separator:aa7f30c1c72bf9891979a428ddf7a03c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f1d03e4c63cece35113e6cc04fb2cc"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#af7f1d03e4c63cece35113e6cc04fb2cc">instr_is_encoding_possible</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:af7f1d03e4c63cece35113e6cc04fb2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d194e7ce235e330a28686db29ee5480"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#a3d194e7ce235e330a28686db29ee5480">instr_encode</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *pc)</td></tr>
<tr class="separator:a3d194e7ce235e330a28686db29ee5480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285a9fb1eaa589b9bb143c8c85861b2b"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#a285a9fb1eaa589b9bb143c8c85861b2b">instr_encode_to_copy</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *copy_pc, byte *final_pc)</td></tr>
<tr class="separator:a285a9fb1eaa589b9bb143c8c85861b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d414952f335eaee8221c2a0e65ea46"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#a04d414952f335eaee8221c2a0e65ea46">instrlist_encode</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, byte *pc, bool has_instr_jmp_targets)</td></tr>
<tr class="separator:a04d414952f335eaee8221c2a0e65ea46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eacc8e4f757c7d3ed0e29f464021522"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#a8eacc8e4f757c7d3ed0e29f464021522">instrlist_encode_to_copy</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, byte *copy_pc, byte *final_pc, byte *max_pc, bool has_instr_jmp_targets)</td></tr>
<tr class="separator:a8eacc8e4f757c7d3ed0e29f464021522"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encoding routines. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a1ab4eb589819195ae2674b22546e3b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab4eb589819195ae2674b22546e3b4a">&#9670;&nbsp;</a></span>dr_isa_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074a">_dr_isa_mode_t</a> <a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies which processor mode to use when decoding or encoding. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a00e03b2e5e75a83eacf9a0ee1674074a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e03b2e5e75a83eacf9a0ee1674074a">&#9670;&nbsp;</a></span>_dr_isa_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074a">_dr_isa_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies which processor mode to use when decoding or encoding. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aa4216aed26374dfaaf5b8e64c8bfc9c6c"></a>DR_ISA_IA32&#160;</td><td class="fielddoc"><p>IA-32 (Intel/AMD 32-bit mode). </p>
</td></tr>
<tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aa6bec3bf2d3d264dfa7dbf67d18b47c41"></a>DR_ISA_X86&#160;</td><td class="fielddoc"><p>Alias for DR_ISA_IA32. </p>
</td></tr>
<tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aabd60fe0abfbb90ba431205b7e5345ac0"></a>DR_ISA_AMD64&#160;</td><td class="fielddoc"><p>AMD64 (Intel/AMD 64-bit mode). </p>
</td></tr>
<tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aa28dc5f6ff81766706362bfb7494a0494"></a>DR_ISA_ARM_A32&#160;</td><td class="fielddoc"><p>ARM A32 (AArch32 ARM). </p>
</td></tr>
<tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aa3f721209faa0616ff181a7bf207a59cc"></a>DR_ISA_ARM_THUMB&#160;</td><td class="fielddoc"><p>Thumb (ARM T32). </p>
</td></tr>
<tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aaefbc35f57a99a1464fda9d6d75dd8445"></a>DR_ISA_ARM_A64&#160;</td><td class="fielddoc"><p>ARM A64 (AArch64). </p>
</td></tr>
<tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aa9afde26779516aec4b89b27bb67e5b18"></a>DR_ISA_RV64&#160;</td><td class="fielddoc"><p>RISC-V (RV64). </p>
</td></tr>
<tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3"></a>DR_ISA_REGDEPS&#160;</td><td class="fielddoc"><p>A synthetic ISA that has the purpose of preserving register dependencies and giving hints on the type of operation an instruction performs.</p>
<p>Being a synthetic ISA, some routines that work on instructions coming from an actual ISA (such as <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aabd60fe0abfbb90ba431205b7e5345ac0">DR_ISA_AMD64</a>) are not supported (e.g., <a class="el" href="dr__ir__decode_8h.html#af4a2c830c95757037eaa1a192a22aa3a">decode_sizeof()</a>).</p>
<p>Currently we support:</p><ul>
<li><a class="el" href="dr__ir__instr_8h.html#a5206491d7fb853236584bc81df58027b">instr_convert_to_isa_regdeps()</a>: to convert an <a class="el" href="structinstr__t.html">instr_t</a> of an actual ISA to a <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> <a class="el" href="structinstr__t.html">instr_t</a>.</li>
<li><a class="el" href="dr__ir__encode_8h.html#a3d194e7ce235e330a28686db29ee5480">instr_encode()</a> and <a class="el" href="dr__ir__encode_8h.html#a285a9fb1eaa589b9bb143c8c85861b2b">instr_encode_to_copy()</a>: to encode a <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> <a class="el" href="structinstr__t.html">instr_t</a> into a sequence of contiguous bytes.</li>
<li><a class="el" href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode()</a> and <a class="el" href="dr__ir__decode_8h.html#abf858ce8d17c1221ea6121f1bb437348">decode_from_copy()</a>: to decode an encoded <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> instruction into an <a class="el" href="structinstr__t.html">instr_t</a>.</li>
</ul>
<p>A <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> <a class="el" href="structinstr__t.html">instr_t</a> contains the following information:</p><ul>
<li>categories: composed by <a class="el" href="dr__ir__instr_8h.html#a6a293267f240f04a49586895b3b67893">dr_instr_category_t</a> values, they indicate the type of operation performed (e.g., a load, a store, a floating point math operation, a branch, etc.). Note that categories are composable, hence more than one category can be set. This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#a2bb8455e57af9ec7f3e60c04aa5723bc">instr_get_category()</a>.</li>
<li>arithmetic flags: we don't distinguish between different flags, we only report if at least one arithmetic flag was read (all arithmetic flags will be set to read) and/or written (all arithmetic flags will be set to written). This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#a08af81c9de9f4f78c309ca59016398e4">instr_get_arith_flags()</a>.</li>
<li>number of source and destination operands: we only consider register operands. This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#ab264f741f5a1edea068dbabb90b4e4c6">instr_num_srcs()</a> and <a class="el" href="dr__ir__instr_8h.html#a3574118088b6a3a5a9b3b7308da90ed7">instr_num_dsts()</a>.</li>
<li>source operation size: is the largest source operand the instruction operates on. This information can be obtained by accessing the <a class="el" href="structinstr__t.html">instr_t</a> operation_size field.</li>
<li>list of register operand identifiers: they are contained in <a class="el" href="structopnd__t.html">opnd_t</a> lists, separated in source and destination. Note that these <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> identifiers are virtual and it should not be assumed that they belong to any DR_REG_ enum value of any specific architecture. These identifiers are meant for tracking register dependencies with respect to other <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> instructions only. These lists can be obtained by walking the <a class="el" href="structinstr__t.html">instr_t</a> operands with <a class="el" href="dr__ir__instr_8h.html#a82807d01f70f547181c3b09e09548f6b">instr_get_dst()</a> and <a class="el" href="dr__ir__instr_8h.html#a38157d3c73c39d022efd47ddba1f666d">instr_get_src()</a>.</li>
<li>ISA mode: is always <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a>. This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#a4362c9281f6555d65240e447eed9e5c0">instr_get_isa_mode()</a>.</li>
<li>encoding bytes: an array of bytes containing the <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> <a class="el" href="structinstr__t.html">instr_t</a> encoding. Note that this information is present only for decoded instructions (i.e., <a class="el" href="structinstr__t.html">instr_t</a> generated by <a class="el" href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode()</a> or <a class="el" href="dr__ir__decode_8h.html#abf858ce8d17c1221ea6121f1bb437348">decode_from_copy()</a>). This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#adf6288f48a76fdea2523a97ec5664d87">instr_get_raw_bits()</a>.</li>
<li>length: the length of the encoded instruction in bytes. Note that this information is present only for decoded instructions (i.e., <a class="el" href="structinstr__t.html">instr_t</a> generated by <a class="el" href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode()</a> or <a class="el" href="dr__ir__decode_8h.html#abf858ce8d17c1221ea6121f1bb437348">decode_from_copy()</a>). This information can be obtained by accessing the <a class="el" href="structinstr__t.html">instr_t</a> length field.</li>
</ul>
<p>Note that all routines that operate on <a class="el" href="structinstr__t.html">instr_t</a> and <a class="el" href="structopnd__t.html">opnd_t</a> are also supported for <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> instructions. However, querying information outside of those described above (e.g., the instruction opcode with <a class="el" href="dr__ir__instr_8h.html#a99682422e3f2060e3b85a61ef7e4fbbb">instr_get_opcode()</a>) will return the zeroed value set by <a class="el" href="dr__ir__instr_8h.html#a9d9a1662aed6669a42a8284dae0e8019">instr_create()</a> or <a class="el" href="dr__ir__instr_8h.html#af7e998e183e87480e7fd82240ff6633d">instr_init()</a> when the <a class="el" href="structinstr__t.html">instr_t</a> was created (e.g., <a class="el" href="dr__ir__instr_8h.html#a99682422e3f2060e3b85a61ef7e4fbbb">instr_get_opcode()</a> would return OP_INVALID). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae8f9b08f90490fbeae26d12a461af084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f9b08f90490fbeae26d12a461af084">&#9670;&nbsp;</a></span>dr_get_isa_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API <a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a> dr_get_isa_mode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The decode and encode routines use a per-thread persistent flag that indicates which processor mode to use. This routine returns the value of that flag. </p>

</div>
</div>
<a id="aa7f30c1c72bf9891979a428ddf7a03c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f30c1c72bf9891979a428ddf7a03c0">&#9670;&nbsp;</a></span>dr_get_vector_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int dr_get_vector_length </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read AArch64 SVE or RISC-V Vector's vector length, in bits. </p>

</div>
</div>
<a id="a988d4acb4851873453253a91d9521bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988d4acb4851873453253a91d9521bce">&#9670;&nbsp;</a></span>dr_set_isa_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_set_isa_mode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a>&#160;</td>
          <td class="paramname"><em>new_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a> *old_mode&#160;</td>
          <td class="paramname"><em>DR_PARAM_OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The decode and encode routines use a per-thread persistent flag that indicates which processor mode to use. This routine sets that flag to the indicated value and optionally returns the old value. Be sure to restore the old value prior to any further application execution to avoid problems in mis-interpreting application code. </p>

</div>
</div>
<a id="afd3e82d2bfed58e3bfc89c0b98f2a5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3e82d2bfed58e3bfc89c0b98f2a5da">&#9670;&nbsp;</a></span>dr_set_vector_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_set_vector_length </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>AArch64 Scalable Vector Extension's vector length in bits is one of: 128 256 384 512 640 768 896 1024 1152 1280 1408 1536 1664 1792 1920 2048</li>
<li>RISC-V Vector Extension's vector length in bit is from 64 to 65536 in the power of 2. Returns whether successful. TODO i#3044: This function will only allow setting vector length if not running on SVE or RVV. </li>
</ul>

</div>
</div>
<a id="a3d194e7ce235e330a28686db29ee5480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d194e7ce235e330a28686db29ee5480">&#9670;&nbsp;</a></span>instr_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* instr_encode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes <code>instr</code> into the memory at <code>pc</code>. Uses the x86/x64 mode stored in instr, not the mode of the current thread. Returns the pc after the encoded instr, or NULL if the encoding failed. If instr is a cti with an <a class="el" href="structinstr__t.html">instr_t</a> target, the offset fields of instr and of the target must be set with the respective offsets of each instr_t! (instrlist_encode does this automatically, if the target is in the list). x86 instructions can occupy up to 17 bytes, so the caller should ensure the target location has enough room to avoid overflow. </p><dl class="section note"><dt>Note</dt><dd>: In Thumb mode, some instructions have different behavior depending on whether they are in an IT block. To correctly encode such instructions, they should be encoded within an instruction list with the corresponding IT instruction using <a class="el" href="dr__ir__encode_8h.html#a04d414952f335eaee8221c2a0e65ea46">instrlist_encode()</a>. </dd></dl>

</div>
</div>
<a id="a285a9fb1eaa589b9bb143c8c85861b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285a9fb1eaa589b9bb143c8c85861b2b">&#9670;&nbsp;</a></span>instr_encode_to_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* instr_encode_to_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>final_pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes <code>instr</code> into the memory at <code>copy_pc</code> in preparation for copying to <code>final_pc</code>. Any pc-relative component is encoded as though the instruction were located at <code>final_pc</code>. This allows for direct copying of the encoded bytes to <code>final_pc</code> without re-relativization.</p>
<p>Uses the x86/x64 mode stored in instr, not the mode of the current thread. Returns the pc after the encoded instr, or NULL if the encoding failed. If instr is a cti with an <a class="el" href="structinstr__t.html">instr_t</a> target, the offset fields of instr and of the target must be set with the respective offsets of each instr_t! (instrlist_encode does this automatically, if the target is in the list). x86 instructions can occupy up to 17 bytes, so the caller should ensure the target location has enough room to avoid overflow. </p><dl class="section note"><dt>Note</dt><dd>: In Thumb mode, some instructions have different behavior depending on whether they are in an IT block. To correctly encode such instructions, they should be encoded within an instruction list with the corresponding IT instruction using <a class="el" href="dr__ir__encode_8h.html#a04d414952f335eaee8221c2a0e65ea46">instrlist_encode()</a>. </dd></dl>

</div>
</div>
<a id="af7f1d03e4c63cece35113e6cc04fb2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f1d03e4c63cece35113e6cc04fb2cc">&#9670;&nbsp;</a></span>instr_is_encoding_possible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool instr_is_encoding_possible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> can be encoded as</p><ul>
<li>a valid IA-32 instruction on X86</li>
<li>a valid Armv8-a instruction on AArch64 (Note: The AArch64 encoder/decoder is not complete yet, so DynamoRIO may fail to encode some valid Armv8-a instructions)</li>
<li>a valid Armv7 instruction on ARM </li>
</ul>

</div>
</div>
<a id="a04d414952f335eaee8221c2a0e65ea46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d414952f335eaee8221c2a0e65ea46">&#9670;&nbsp;</a></span>instrlist_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* instrlist_encode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_instr_jmp_targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes each instruction in <code>ilist</code> in turn in contiguous memory starting at <code>pc</code>. Returns the pc after all of the encodings, or NULL if any one of the encodings failed. Uses the x86/x64 mode stored in each instr, not the mode of the current thread. In order for <a class="el" href="structinstr__t.html">instr_t</a> operands to be encoded properly, <code>has_instr_jmp_targets</code> must be true. If <code>has_instr_jmp_targets</code> is true, the offset field of each <a class="el" href="structinstr__t.html">instr_t</a> in ilist will be overwritten, and if any <a class="el" href="structinstr__t.html">instr_t</a> targets are not in <code>ilist</code>, they must have their offset fields set with their offsets relative to pc. x86 instructions can occupy up to 17 bytes each, so the caller should ensure the target location has enough room to avoid overflow. </p>

</div>
</div>
<a id="a8eacc8e4f757c7d3ed0e29f464021522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eacc8e4f757c7d3ed0e29f464021522">&#9670;&nbsp;</a></span>instrlist_encode_to_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* instrlist_encode_to_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>final_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>max_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_instr_jmp_targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes each instruction in <code>ilist</code> in turn in contiguous memory starting <code>copy_pc</code> in preparation for copying to <code>final_pc</code>. Any pc-relative instruction is encoded as though the instruction list were located at <code>final_pc</code>. This allows for direct copying of the encoded bytes to <code>final_pc</code> without re-relativization.</p>
<p>Returns the pc after all of the encodings, or NULL if any one of the encodings failed.</p>
<p>Uses the x86/x64 mode stored in each instr, not the mode of the current thread.</p>
<p>In order for <a class="el" href="structinstr__t.html">instr_t</a> operands to be encoded properly, <code>has_instr_jmp_targets</code> must be true. If <code>has_instr_jmp_targets</code> is true, the offset field of each <a class="el" href="structinstr__t.html">instr_t</a> in ilist will be overwritten, and if any <a class="el" href="structinstr__t.html">instr_t</a> targets are not in <code>ilist</code>, they must have their offset fields set with their offsets relative to pc.</p>
<p>If <code>max_pc</code> is non-NULL, computes the total size required to encode the instruction list before performing any encoding. If the whole list will not fit starting at <code>copy_pc</code> without exceeding <code>max_pc</code>, returns NULL without encoding anything. Otherwise encodes as normal. Note that x86 instructions can occupy up to 17 bytes each, so if <code>max_pc</code> is NULL, the caller should ensure the target location has enough room to avoid overflow. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_a0483f3cd378439baf400a8ae9c26877.html">include</a></li><li class="navelem"><a class="el" href="dr__ir__encode_8h.html">dr_ir_encode.h</a></li>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 10.93.19965 --- Sat Aug 31 2024 02:43:14 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
